import { test, expect } from '@playwright/test';

/**
 * E2E Test: Multi-View Design Element Rendering
 * 
 * This test verifies that:
 * 1. Design elements render properly on project load
 * 2. Switching between Front and Back views displays the correct design elements
 * 3. Only elements for the active view are visible
 */
test.describe('Multi-View Design Element Rendering', () => {
  // Test credentials - can be set via environment variables or .env.test file
  const TEST_EMAIL = process.env.TEST_EMAIL || 'toledo.eric@gmail.com';
  const TEST_PASSWORD = process.env.TEST_PASSWORD || 'test123';
  
  // Test project ID - should be a project that has both front and back views
  const TEST_PROJECT_ID = process.env.TEST_PROJECT_ID || 'a85035e5-21b9-49c9-8762-d3f9a1dd9a12';

  test.beforeEach(async ({ page }) => {
    // Navigate to login page
    await page.goto('/login');
    
    // Wait for login form to be visible
    await page.waitForSelector('input[name="email"]', { timeout: 10000 });
    
    // Fill in login credentials
    const emailInput = page.locator('input[name="email"]');
    const passwordInput = page.locator('input[name="password"]');
    
    await emailInput.fill(TEST_EMAIL);
    await passwordInput.fill(TEST_PASSWORD);
    
    // Submit login form - wait for button to be enabled
    const submitButton = page.locator('button[type="submit"]:has-text("Login")');
    await submitButton.waitFor({ state: 'visible', timeout: 5000 });
    
    // Click and wait for navigation
    await Promise.all([
      page.waitForURL(/\/(projects|selection)/, { timeout: 20000 }),
      submitButton.click()
    ]);
    
    // Wait for page to be fully loaded
    await page.waitForLoadState('domcontentloaded');
    
    // Verify we're authenticated by checking URL
    const currentUrl = page.url();
    if (!currentUrl.includes('/projects') && !currentUrl.includes('/selection')) {
      throw new Error(`Login failed - redirected to ${currentUrl} instead of /projects or /selection`);
    }
  });

  test('should render design elements on project load and switch views correctly', async ({ page }) => {
    // Debug: Log current URL after login
    console.log('After login, current URL:', page.url());
    
    // Ensure we're authenticated - navigate to projects if needed
    if (!page.url().includes('/projects') && !page.url().includes('/selection')) {
      console.log('Not on projects page, navigating...');
      await page.goto('/projects');
      await page.waitForLoadState('domcontentloaded');
    }
    
    // Wait for projects list to load (just to ensure page is ready)
    await page.waitForSelector('.project-card, [data-testid="project-card"], .card', { timeout: 10000 }).catch(() => {
      // Projects list might not be visible, that's okay if we have TEST_PROJECT_ID
    });
    
    // Use TEST_PROJECT_ID directly if provided
    let projectIdToUse = TEST_PROJECT_ID;
    
    if (!TEST_PROJECT_ID || TEST_PROJECT_ID === 'your-test-project-id-with-front-and-back-views') {
      // No TEST_PROJECT_ID provided, try to find one from the page
      console.log('No TEST_PROJECT_ID provided, attempting to find project from list...');
      
      const projectCards = page.locator('.project-card, [data-testid="project-card"], .card, [class*="project"]');
      const projectCount = await projectCards.count();
      
      if (projectCount === 0) {
        throw new Error('No projects found and no TEST_PROJECT_ID provided. Please create a project first or set TEST_PROJECT_ID in .env.test');
      }
      
      // Try to extract project IDs from the page
      const projectIds = await page.evaluate(() => {
        const links = Array.from(document.querySelectorAll('a[href*="/projects/"]'));
        const ids = [];
        links.forEach(link => {
          const href = link.getAttribute('href');
          const match = href.match(/\/projects\/([a-f0-9-]+)\//);
          if (match && match[1]) {
            ids.push(match[1]);
          }
        });
        return [...new Set(ids)]; // Remove duplicates
      });
      
      if (projectIds.length > 0) {
        projectIdToUse = projectIds[0];
        console.log(`Using first project ID from list: ${projectIdToUse}`);
      } else {
        // Fallback: try clicking the Edit button on the first project card
        console.log('Could not extract project IDs from links, trying Edit button...');
      
      // Look for Edit button (for draft projects) or the card itself
      const editButton = page.locator('button:has-text("Edit"), .edit-project-btn').first();
      const editButtonCount = await editButton.count();
      
      if (editButtonCount > 0) {
        console.log('Found Edit button, clicking...');
        // The Edit button opens a modal, not navigates - so we need to click the card instead
        // Actually, let's just click the card directly
        const firstCard = projectCards.first();
        await firstCard.click({ force: true });
      } else {
        // No Edit button, try clicking the card directly
        console.log('No Edit button found, clicking project card directly...');
        const firstCard = projectCards.first();
        await firstCard.click({ force: true });
      }
      
      // Wait a moment for any navigation or modal to appear
      await page.waitForTimeout(2000);
      
      const urlAfterClick = page.url();
      console.log(`After clicking, URL is: ${urlAfterClick}`);
      
      // If we're still on projects page, the click didn't work - try a different approach
      if (urlAfterClick === 'http://localhost:3000/projects' || urlAfterClick.includes('/projects') && !urlAfterClick.includes('/edit') && !urlAfterClick.includes('/approved')) {
        // Try using the first project's data directly by inspecting the page
        const projectData = await page.evaluate(() => {
          // Look for project data in React component state or DOM attributes
          const cards = document.querySelectorAll('.project-card, [class*="project-card"]');
          if (cards.length > 0) {
            // Try to get project ID from data attributes or React props
            const card = cards[0];
            const projectId = card.getAttribute('data-project-id') || 
                            card.getAttribute('data-id') ||
                            card.id?.replace('project-', '');
            return projectId;
          }
          return null;
        });
        
        if (projectData) {
          projectIdToUse = projectData;
          console.log(`Extracted project ID from DOM: ${projectIdToUse}`);
          await page.goto(`/projects/${projectIdToUse}/edit`, { waitUntil: 'domcontentloaded' });
        } else {
          // Provide helpful error message with instructions
          const projectsVisible = await page.locator('.project-card, [data-testid="project-card"], .card').count();
          throw new Error(
            `Could not navigate to project edit page. ` +
            `Found ${projectsVisible} project(s) visible, but clicking did not work. ` +
            `Please set TEST_PROJECT_ID in .env.test with a valid project ID. ` +
            `To get a project ID: 1) Log into the app, 2) Click on a draft project, 3) Copy the ID from the URL (/projects/{ID}/edit)`
          );
        }
      } else {
        // Navigation worked, extract project ID
        const match = urlAfterClick.match(/\/projects\/([a-f0-9-]+)\//);
        if (match && match[1]) {
          projectIdToUse = match[1];
          console.log(`Got project ID from navigation: ${projectIdToUse}`);
          
          // If we're on approved page, we can't edit it
          if (urlAfterClick.includes('/approved')) {
            throw new Error(`Project ${projectIdToUse} is approved and cannot be edited. Please use a draft project for testing.`);
          }
        }
      }
    }
    
    // If we have a projectIdToUse and we're not on the edit page, navigate there
    if (projectIdToUse && projectIdToUse !== TEST_PROJECT_ID) {
      const currentUrl = page.url();
      if (!currentUrl.includes('/edit')) {
        console.log(`Navigating to project edit page: /projects/${projectIdToUse}/edit`);
        await page.goto(`/projects/${projectIdToUse}/edit`, { waitUntil: 'domcontentloaded' });
      }
    } else if (projectIdToUse && projectIdToUse === TEST_PROJECT_ID) {
      // We already tried to navigate above, just ensure we're on the right page
      const currentUrl = page.url();
      if (!currentUrl.includes('/edit')) {
        await page.goto(`/projects/${projectIdToUse}/edit`, { waitUntil: 'domcontentloaded' });
      }
    }
    
    // Log current URL to see if we're redirected
    const currentUrl = page.url();
    console.log('After navigation, current URL:', currentUrl);
    
    // Wait for the page to be interactive
    await page.waitForLoadState('domcontentloaded');
    
    // Check if we got redirected (e.g., to login or approval page)
    if (currentUrl.includes('/login')) {
      throw new Error('Got redirected to login - authentication failed');
    }
    if (currentUrl.includes('/approved')) {
      throw new Error(`Project ${TEST_PROJECT_ID} is approved and cannot be edited. Please use a draft project for testing.`);
    }
    if (currentUrl === '/projects' || currentUrl.includes('/projects') && !currentUrl.includes('/edit')) {
      // Check for error messages
      const errorText = await page.textContent('body');
      if (errorText.includes('Error') || errorText.includes('not found')) {
        throw new Error(`Project ${TEST_PROJECT_ID} not found or error loading. Error: ${errorText.substring(0, 200)}`);
      }
      throw new Error(`Got redirected back to projects list. Project ${TEST_PROJECT_ID} may not exist or may not be accessible.`);
    }
    
    // Ensure we're actually on the edit page
    if (!currentUrl.includes('/edit')) {
      throw new Error(`Expected to be on edit page but got: ${currentUrl}`);
    }
    
    // Wait a bit and check if we get redirected (project might not exist or have an error)
    await page.waitForTimeout(3000);
    
    // Check if we got redirected after waiting
    const finalUrl = page.url();
    if (finalUrl !== currentUrl) {
      console.log(`Redirect detected: ${currentUrl} -> ${finalUrl}`);
      if (finalUrl.includes('/projects') && !finalUrl.includes('/edit')) {
        // The project doesn't exist or there's an error
        // Try to find a valid project from the list instead
        console.log('Project not found, attempting to find a valid project from the list...');
        
        // Go back to projects list and click the first project
        await page.goto('/projects');
        await page.waitForSelector('.project-card, [data-testid="project-card"], .card', { timeout: 10000 });
        
        // Click the "Edit" button or the project card itself
        const editButton = page.locator('button:has-text("Edit"), a:has-text("Edit")').first();
        const editButtonCount = await editButton.count();
        
        if (editButtonCount > 0) {
          await editButton.click();
        } else {
          // Try clicking the project card itself
          const firstCard = page.locator('.project-card, [data-testid="project-card"], .card').first();
          await firstCard.click();
        }
        
        // Wait for navigation
        await page.waitForURL(/\/(projects\/[^\/]+\/edit|projects\/[^\/]+\/approved)/, { timeout: 10000 });
        const newUrl = page.url();
        
        if (newUrl.includes('/approved')) {
          throw new Error('The first available project is approved and cannot be edited. Please create a draft project for testing.');
        }
        
        if (!newUrl.includes('/edit')) {
          throw new Error(`Could not navigate to project edit page. Final URL: ${newUrl}`);
        }
        
        console.log(`Successfully navigated to project edit page: ${newUrl}`);
      }
    }
    
    // Wait for any loading indicators first
    await page.waitForTimeout(1000);
    
    // Listen for console errors
    const consoleErrors = [];
    page.on('console', msg => {
      if (msg.type() === 'error') {
        consoleErrors.push(msg.text());
      }
    });
    
    // Listen for page errors
    page.on('pageerror', error => {
      consoleErrors.push(error.message);
    });
    
    // Check what's actually on the page
    const pageContent = await page.content();
    if (pageContent.includes('Loading') || pageContent.includes('loading')) {
      console.log('Page shows loading state, waiting...');
    }
    const pageText = await page.textContent('body');
    console.log('Page body text (first 500 chars):', pageText?.substring(0, 500));
    
    // Check for error messages
    const errorMessages = await page.locator('.error, .error-message, [class*="error"], [class*="Error"]').all();
    if (errorMessages.length > 0) {
      for (const elem of errorMessages) {
        const text = await elem.textContent();
        console.error('Error message found:', text);
      }
    }
    
    // Check if DesignStudio component rendered at all
    const designStudioExists = await page.locator('.design-studio').count();
    console.log('Design studio component count:', designStudioExists);
    
    if (designStudioExists === 0) {
      // Check if there's a loading state or error
      const loadingExists = await page.locator('[class*="loading"], [class*="Loading"]').count();
      const noDataExists = await page.locator('[class*="no"], [class*="No"]').count();
      console.log('Loading indicators:', loadingExists);
      console.log('No data indicators:', noDataExists);
      
      // Take a screenshot to see what's happening
      await page.screenshot({ path: 'test-results/page-state.png', fullPage: true });
      throw new Error('DesignStudio component not found on page. Check test-results/page-state.png');
    }
    
    // Wait for DesignStudio to load - check for the canvas container
    try {
      console.log('Waiting for design studio to load...');
      await page.waitForSelector('.design-studio-canvas-container', { timeout: 60000, state: 'visible' });
      console.log('Design studio container found!');
    } catch (error) {
      console.error('Design studio container not found');
      
      // Check what elements are present
      const allElements = await page.evaluate(() => {
        return {
          designStudio: document.querySelector('.design-studio') ? 'found' : 'not found',
          canvasContainer: document.querySelector('.design-studio-canvas-container') ? 'found' : 'not found',
          anyCanvas: document.querySelectorAll('canvas').length,
          bodyClasses: document.body.className,
          title: document.title
        };
      });
      console.error('Page elements:', allElements);
      
      throw error;
    }
    
    // Wait for canvas to appear (it might take time to initialize)
    // The canvas elements have specific classes: .fabric-canvas and .product-canvas
    let canvasFound = false;
    try {
      console.log('Waiting for canvas to appear...');
      
      // Wait for the fabric canvas specifically (the interactive one)
      await page.waitForSelector('canvas.fabric-canvas', { timeout: 90000, state: 'attached' });
      canvasFound = true;
      console.log('Fabric canvas found!');
      
      // Also wait for it to be visible
      await page.waitForSelector('canvas.fabric-canvas', { timeout: 10000, state: 'visible' });
      console.log('Fabric canvas is visible!');
    } catch (error) {
      console.log('Canvas not found within timeout, checking page state...');
      
      // Check if page is still valid
      try {
        const pageTitle = await page.title();
        const pageUrl = page.url();
        console.error('Page title:', pageTitle);
        console.error('Page URL:', pageUrl);
        
        // Check for error messages on the page
        const errorElements = await page.locator('.error, .error-message, [class*="error"]').all();
        if (errorElements.length > 0) {
          for (const elem of errorElements) {
            const text = await elem.textContent();
            console.error('Error on page:', text);
          }
        }
        
        // Check for canvas in DOM (might be hidden)
        const canvasInDOM = await page.evaluate(() => {
          const allCanvases = document.querySelectorAll('canvas');
          const fabricCanvas = document.querySelector('canvas.fabric-canvas');
          const productCanvas = document.querySelector('canvas.product-canvas');
          const container = document.querySelector('.design-studio-canvas-container');
          
          return {
            totalCanvases: allCanvases.length,
            fabricCanvas: {
              exists: !!fabricCanvas,
              visible: fabricCanvas ? window.getComputedStyle(fabricCanvas).display !== 'none' : false
            },
            productCanvas: {
              exists: !!productCanvas,
              visible: productCanvas ? window.getComputedStyle(productCanvas).display !== 'none' : false
            },
            containerExists: !!container,
            containerVisible: container ? window.getComputedStyle(container).display !== 'none' : false
          };
        });
        console.error('Canvas elements in DOM:', canvasInDOM);
        
        // Take screenshot for debugging
        try {
          const screenshotPath = `test-results/canvas-not-found-${Date.now()}.png`;
          await page.screenshot({ path: screenshotPath, fullPage: true });
          console.error(`Screenshot saved to ${screenshotPath}`);
        } catch (screenshotError) {
          console.error('Could not take screenshot:', screenshotError.message);
        }
        
        // Log console errors
        if (consoleErrors.length > 0) {
          console.error('Console errors:', consoleErrors);
        }
      } catch (pageError) {
        console.error('Page is closed or invalid:', pageError.message);
      }
      
      throw error;
    }
    
    // Wait for canvas to be visible
    const canvas = page.locator('canvas').first();
    await canvas.waitFor({ state: 'visible', timeout: 30000 });
    
    // Wait for loading spinner to disappear (if present)
    // Check for various spinner selectors
    const spinnerSelectors = [
      '[data-testid="loading-spinner"]',
      '.loading-spinner',
      '.spinner',
      '[class*="loading"]',
      '[class*="spinner"]'
    ];
    
    for (const selector of spinnerSelectors) {
      const spinner = page.locator(selector);
      const count = await spinner.count();
      if (count > 0) {
        try {
          await spinner.first().waitFor({ state: 'hidden', timeout: 30000 });
        } catch (e) {
          // Spinner might not hide, continue anyway
        }
      }
    }
    
    // Wait for canvas to be fully initialized and Fabric.js to be ready
    await page.waitForFunction(() => {
      return window.__fabricCanvasInstance !== undefined && 
             window.__fabricCanvasInstance !== null &&
             window.__fabricCanvasInstance.getObjects !== undefined;
    }, { timeout: 60000 });
    
    // Additional wait for canvas to render
    await page.waitForTimeout(3000);

    // Verify canvas is present and has content
    await expect(canvas).toBeVisible();
    
    // Get canvas element count using JavaScript evaluation
    const canvasObjectCount = await page.evaluate(() => {
      const canvasElement = document.querySelector('canvas');
      if (!canvasElement) {
        console.error('No canvas element found');
        return { count: 0, error: 'No canvas element' };
      }
      
      // Access Fabric.js canvas instance if available
      // The useFabricCanvas hook exposes it on window.__fabricCanvasInstance
      const fabricCanvas = window.__fabricCanvasInstance || canvasElement.__canvas || window.fabricCanvas;
      if (!fabricCanvas) {
        console.error('Fabric.js canvas instance not found');
        return { count: 0, error: 'Fabric.js not initialized', hasCanvas: true };
      }
      
      if (!fabricCanvas.getObjects) {
        console.error('Fabric.js canvas does not have getObjects method');
        return { count: 0, error: 'Invalid canvas instance', hasCanvas: true, hasFabric: true };
      }
      
      const objects = fabricCanvas.getObjects();
      // Filter out constraint overlay and other non-design objects
      const designObjects = objects.filter(obj => !obj.excludeFromExport);
      return { 
        count: designObjects.length, 
        totalObjects: objects.length,
        designObjects: designObjects.length
      };
    });
    
    console.log(`Initial canvas object count:`, canvasObjectCount);
    
    if (canvasObjectCount.error) {
      throw new Error(`Canvas initialization error: ${canvasObjectCount.error}`);
    }
    
    expect(canvasObjectCount.count || canvasObjectCount.designObjects).toBeGreaterThan(0);

    // Verify view controller is present
    const viewController = page.locator('.control-group').filter({ hasText: /Front|Back/ });
    await expect(viewController).toBeVisible();
    
    // Verify Front button is present and active
    const frontButton = page.locator('.control-item.view:has-text("Front")');
    await expect(frontButton).toBeVisible();
    await expect(frontButton).toHaveClass(/active/);

    // Get initial front view element count
    const frontViewElementCount = await page.evaluate(() => {
      const canvasElement = document.querySelector('canvas');
      if (!canvasElement) return 0;
      const fabricCanvas = window.__fabricCanvasInstance || canvasElement.__canvas || window.fabricCanvas;
      if (fabricCanvas && fabricCanvas.getObjects) {
        const objects = fabricCanvas.getObjects();
        return objects.filter(obj => {
          if (obj.excludeFromExport) return false;
          const viewId = obj.viewId || obj.get?.('viewId');
          return viewId === 'front' || viewId === 'Front';
        }).length;
      }
      return 0;
    });
    
    console.log(`Front view element count: ${frontViewElementCount}`);
    expect(frontViewElementCount).toBeGreaterThan(0);

    // Verify Back button is present
    const backButton = page.locator('.control-item.view:has-text("Back")');
    await expect(backButton).toBeVisible();
    
    // Click Back button to switch to back view
    await backButton.click();
    
    // Wait for view switch to complete
    await page.waitForTimeout(1000);
    
    // Verify Back button is now active
    await expect(backButton).toHaveClass(/active/);
    await expect(frontButton).not.toHaveClass(/active/);

    // Verify only back view elements are visible
    const backViewElementCount = await page.evaluate(() => {
      const canvasElement = document.querySelector('canvas');
      if (!canvasElement) return 0;
      const fabricCanvas = window.__fabricCanvasInstance || canvasElement.__canvas || window.fabricCanvas;
      if (fabricCanvas && fabricCanvas.getObjects) {
        const objects = fabricCanvas.getObjects();
        const visibleObjects = objects.filter(obj => {
          if (obj.excludeFromExport) return false;
          const viewId = obj.viewId || obj.get?.('viewId');
          const isVisible = obj.visible !== false && obj.opacity !== 0;
          return isVisible;
        });
        
        // Check that visible objects belong to back view
        const backViewObjects = visibleObjects.filter(obj => {
          const viewId = obj.viewId || obj.get?.('viewId');
          const normalizedViewId = String(viewId).toLowerCase().trim();
          return normalizedViewId === 'back';
        });
        
        // Check that no front view objects are visible
        const frontViewObjects = visibleObjects.filter(obj => {
          const viewId = obj.viewId || obj.get?.('viewId');
          const normalizedViewId = String(viewId).toLowerCase().trim();
          return normalizedViewId === 'front';
        });
        
        return {
          totalVisible: visibleObjects.length,
          backViewCount: backViewObjects.length,
          frontViewCount: frontViewObjects.length,
          allVisibleObjects: visibleObjects.map(obj => ({
            elementId: obj.elementId,
            viewId: obj.viewId || obj.get?.('viewId'),
            visible: obj.visible,
            opacity: obj.opacity,
            type: obj.type
          }))
        };
      }
      return { totalVisible: 0, backViewCount: 0, frontViewCount: 0, allVisibleObjects: [] };
    });
    
    console.log('Back view element counts:', backViewElementCount);
    
    // Verify back view has elements
    expect(backViewElementCount.backViewCount).toBeGreaterThan(0);
    
    // Verify no front view elements are visible
    expect(backViewElementCount.frontViewCount).toBe(0);
    
    // Verify total visible count matches back view count
    expect(backViewElementCount.totalVisible).toBe(backViewElementCount.backViewCount);

    // Switch back to Front view
    await frontButton.click();
    
    // Wait for view switch to complete
    await page.waitForTimeout(1000);
    
    // Verify Front button is now active
    await expect(frontButton).toHaveClass(/active/);
    await expect(backButton).not.toHaveClass(/active/);

    // Verify only front view elements are visible
    const frontViewElementCountAfterSwitch = await page.evaluate(() => {
      const canvasElement = document.querySelector('canvas');
      if (!canvasElement) return 0;
      const fabricCanvas = window.__fabricCanvasInstance || canvasElement.__canvas || window.fabricCanvas;
      if (fabricCanvas && fabricCanvas.getObjects) {
        const objects = fabricCanvas.getObjects();
        const visibleObjects = objects.filter(obj => {
          if (obj.excludeFromExport) return false;
          const isVisible = obj.visible !== false && obj.opacity !== 0;
          return isVisible;
        });
        
        // Check that visible objects belong to front view
        const frontViewObjects = visibleObjects.filter(obj => {
          const viewId = obj.viewId || obj.get?.('viewId');
          const normalizedViewId = String(viewId).toLowerCase().trim();
          return normalizedViewId === 'front';
        });
        
        // Check that no back view objects are visible
        const backViewObjects = visibleObjects.filter(obj => {
          const viewId = obj.viewId || obj.get?.('viewId');
          const normalizedViewId = String(viewId).toLowerCase().trim();
          return normalizedViewId === 'back';
        });
        
        return {
          totalVisible: visibleObjects.length,
          frontViewCount: frontViewObjects.length,
          backViewCount: backViewObjects.length,
          allVisibleObjects: visibleObjects.map(obj => ({
            elementId: obj.elementId,
            viewId: obj.viewId || obj.get?.('viewId'),
            visible: obj.visible,
            opacity: obj.opacity,
            type: obj.type
          }))
        };
      }
      return { totalVisible: 0, frontViewCount: 0, backViewCount: 0, allVisibleObjects: [] };
    });
    
    console.log('Front view element counts after switch:', frontViewElementCountAfterSwitch);
    
    // Verify front view has elements
    expect(frontViewElementCountAfterSwitch.frontViewCount).toBeGreaterThan(0);
    
    // Verify no back view elements are visible
    expect(frontViewElementCountAfterSwitch.backViewCount).toBe(0);
    
    // Verify total visible count matches front view count
    expect(frontViewElementCountAfterSwitch.totalVisible).toBe(frontViewElementCountAfterSwitch.frontViewCount);
  });

  test('should handle projects with only front view', async ({ page }) => {
    // This test verifies that projects with only front view don't show view controller
    // Navigate to a project (you may need to create one or use a different project ID)
    // For now, we'll just verify the view controller logic
    
    await page.goto('/projects');
    await page.waitForSelector('.project-card, [data-testid="project-card"]', { timeout: 10000 });
    
    // Click on first project
    const firstProject = page.locator('.project-card, [data-testid="project-card"]').first();
    await firstProject.click();
    
    // Wait for edit page to load
    await page.waitForSelector('canvas', { timeout: 30000 });
    await page.waitForTimeout(2000);
    
    // Check if view controller exists
    const viewController = page.locator('.control-group').filter({ hasText: /Front|Back/ });
    const viewControllerExists = await viewController.count() > 0;
    
    if (viewControllerExists) {
      // If view controller exists, verify it works
      const frontButton = page.locator('.control-item.view:has-text("Front")');
      if (await frontButton.count() > 0) {
        await expect(frontButton).toBeVisible();
      }
    } else {
      // If no view controller, that's fine for single-view projects
      console.log('No view controller found - project likely has only one view');
    }
  });
});

