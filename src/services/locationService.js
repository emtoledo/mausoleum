/**
 * Location Service
 * Handles CRUD operations for locations
 */

import { supabase } from '../lib/supabase';

class LocationService {
  /**
   * Get location by slug
   * @param {string} slug - Location slug
   * @returns {Promise<{success: boolean, data?: Object, error?: string}>}
   */
  async getLocationBySlug(slug) {
    try {
      if (!slug) {
        return { success: false, error: 'Slug is required' };
      }

      const { data, error } = await supabase
        .from('locations')
        .select('*')
        .eq('slug', slug)
        .eq('is_active', true)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          return { success: false, error: 'Location not found' };
        }
        throw error;
      }

      return { success: true, data };
    } catch (error) {
      console.error('Error fetching location by slug:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Get location by ID
   * @param {string} locationId - Location UUID
   * @returns {Promise<{success: boolean, data?: Object, error?: string}>}
   */
  async getLocationById(locationId) {
    try {
      if (!locationId) {
        return { success: false, error: 'Location ID is required' };
      }

      const { data, error } = await supabase
        .from('locations')
        .select('*')
        .eq('id', locationId)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          return { success: false, error: 'Location not found' };
        }
        throw error;
      }

      return { success: true, data };
    } catch (error) {
      console.error('Error fetching location by ID:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Get all locations (master admin only)
   * @returns {Promise<{success: boolean, data?: Array, error?: string}>}
   */
  async getAllLocations() {
    try {
      // Check if user is master admin
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        return { success: false, error: 'Not authenticated' };
      }

      const { data: masterAdmin } = await supabase
        .from('master_admins')
        .select('id')
        .eq('id', user.id)
        .maybeSingle();

      if (!masterAdmin) {
        return { success: false, error: 'Master admin access required' };
      }

      const { data, error } = await supabase
        .from('locations')
        .select('*')
        .order('name', { ascending: true });

      if (error) throw error;

      return { success: true, data: data || [] };
    } catch (error) {
      console.error('Error fetching all locations:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Create a new location
   * @param {Object} locationData - Location data
   * @param {string} locationData.name - Location name
   * @param {string} locationData.slug - Location slug (optional, will be auto-generated)
   * @param {string} locationData.brand_title - Brand title
   * @param {string} locationData.projects_title - Projects title
   * @param {string} locationData.approval_proof_title - Approval proof title
   * @param {string} locationData.background_video_url - Background video URL
   * @param {boolean} locationData.is_active - Active status
   * @returns {Promise<{success: boolean, data?: Object, error?: string}>}
   */
  async createLocation(locationData) {
    try {
      // Check if user is master admin
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        return { success: false, error: 'Not authenticated' };
      }

      const { data: masterAdmin } = await supabase
        .from('master_admins')
        .select('id')
        .eq('id', user.id)
        .maybeSingle();

      if (!masterAdmin) {
        return { success: false, error: 'Master admin access required' };
      }

      const { data, error } = await supabase
        .from('locations')
        .insert({
          name: locationData.name,
          slug: locationData.slug || null, // Will be auto-generated by trigger if null
          brand_title: locationData.brand_title || locationData.name,
          projects_title: locationData.projects_title || locationData.name,
          approval_proof_title: locationData.approval_proof_title || locationData.name,
          background_video_url: locationData.background_video_url || null,
          is_active: locationData.is_active !== undefined ? locationData.is_active : true,
          address: locationData.address || null
        })
        .select()
        .single();

      if (error) throw error;

      return { success: true, data };
    } catch (error) {
      console.error('Error creating location:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Update an existing location
   * @param {string} locationId - Location UUID
   * @param {Object} updates - Location updates
   * @returns {Promise<{success: boolean, data?: Object, error?: string}>}
   */
  async updateLocation(locationId, updates) {
    try {
      // Check if user is master admin
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        return { success: false, error: 'Not authenticated' };
      }

      const { data: masterAdmin } = await supabase
        .from('master_admins')
        .select('id')
        .eq('id', user.id)
        .maybeSingle();

      if (!masterAdmin) {
        return { success: false, error: 'Master admin access required' };
      }

      const updateData = {};
      if (updates.name !== undefined) updateData.name = updates.name;
      if (updates.slug !== undefined) updateData.slug = updates.slug;
      if (updates.brand_title !== undefined) updateData.brand_title = updates.brand_title;
      if (updates.projects_title !== undefined) updateData.projects_title = updates.projects_title;
      if (updates.approval_proof_title !== undefined) updateData.approval_proof_title = updates.approval_proof_title;
      if (updates.background_video_url !== undefined) updateData.background_video_url = updates.background_video_url;
      if (updates.is_active !== undefined) updateData.is_active = updates.is_active;
      if (updates.address !== undefined) updateData.address = updates.address;

      updateData.updated_at = new Date().toISOString();

      const { data, error } = await supabase
        .from('locations')
        .update(updateData)
        .eq('id', locationId)
        .select()
        .single();

      if (error) throw error;

      return { success: true, data };
    } catch (error) {
      console.error('Error updating location:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Delete a location
   * @param {string} locationId - Location UUID
   * @returns {Promise<{success: boolean, error?: string}>}
   */
  async deleteLocation(locationId) {
    try {
      // Check if user is master admin
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        return { success: false, error: 'Not authenticated' };
      }

      const { data: masterAdmin } = await supabase
        .from('master_admins')
        .select('id')
        .eq('id', user.id)
        .maybeSingle();

      if (!masterAdmin) {
        return { success: false, error: 'Master admin access required' };
      }

      // Check if location has associated data
      const { data: projects } = await supabase
        .from('projects')
        .select('id')
        .eq('location_id', locationId)
        .limit(1);

      if (projects && projects.length > 0) {
        return { success: false, error: 'Cannot delete location with associated projects' };
      }

      const { error } = await supabase
        .from('locations')
        .delete()
        .eq('id', locationId);

      if (error) throw error;

      return { success: true };
    } catch (error) {
      console.error('Error deleting location:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Get location configuration (branding, titles, etc.)
   * @param {string} locationId - Location UUID
   * @returns {Promise<{success: boolean, data?: Object, error?: string}>}
   */
  async getLocationConfig(locationId) {
    try {
      const result = await this.getLocationById(locationId);
      if (!result.success) {
        return result;
      }

      const location = result.data;
      return {
        success: true,
        data: {
          brandTitle: location.brand_title || location.name,
          projectsTitle: location.projects_title || location.name,
          approvalProofTitle: location.approval_proof_title || location.name,
          backgroundVideoUrl: location.background_video_url || '/videos/arlington_bg.mp4'
        }
      };
    } catch (error) {
      console.error('Error getting location config:', error);
      return { success: false, error: error.message };
    }
  }
}

// Export singleton instance
const locationService = new LocationService();
export default locationService;

